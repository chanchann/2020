## 派生类和基类的is-a关系仅适用于公有继承

## protected 允许派生类和友元类访问，但禁止在继承层次结构外部访问

## 调用基类在被覆盖的方法 myDinner.Fish::Swim()

## 构造顺序问题

## 私有继承 ：

意味着派生类的实例中，基类的所有公有成员和方法都私有，不能从外部访问

从继承层次外部看，私有继承并非is-a关系。只有子类才能使用基类的属性和方法，所有has-a

## 保护继承

和私有类似，不过就是子类的子类能访问Base类的公有成员

仅当必要时才使用私有或保护继承，更好的选择是将基类对象走位派生类的一个成员属性

利用组合/聚合

```cpp
class Car {
private:
    Motor heartOfCar;
public:
    void move() {
        xxx;
    }
}
```

## slicing问题

基类的指针，const引用

## 多继承

## 不要仅为重用微不足道的方法而创建继承层次

## 多态

使用virtual可保证编译器调用覆盖版本

## 虚析构函数 **

## 虚函数表 **

用于存储函数指针，确保调用正确的虚函数版本

## 抽象基类和纯虚函数

## 使用虚继承解决菱形问题

注意virtual在函数声明和虚继承中是两个概念

## 可将复制构造函数声明为虚函数吗

不支持

多态行为是在运行阶段实现的，而构造函数只能创建固定类型的对象，不具备多态性

但是有不错的解决方案，定义自己的clone函数

## TIPS

对于将被派生类覆盖的基类方法，务必将其声明为虚函数

一定考虑是否为虚继承

别忘了给基类提供一个虚析构函数



